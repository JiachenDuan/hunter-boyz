<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Hunter Boyz</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#05070f; color:#e6edf3; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; touch-action: manipulation; }
    /* iOS long-press / selection prevention */
    body, #ui, canvas, button, input, select, textarea {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      overscroll-behavior: none;
    }
    #ui { position: fixed; inset: 0; pointer-events:none; }
    #hud { position:absolute; top:10px; left:10px; background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:10px 12px; pointer-events:auto; max-width: min(72vw, 420px); display:inline-flex; flex-direction:column; gap:8px; }
    #hud input { border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color:#e6edf3; padding:8px 10px; width: 160px; }
    #hud button { margin-left:6px; border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(124,92,255,0.9); color:white; padding:8px 10px; }

    /* Compact HUD to avoid overlapping the score box when Settings are closed */
    #hud.hudCompact {
      padding: 8px 10px;
      max-width: none;
      width: fit-content;
      display: inline-flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
      backdrop-filter: blur(2px);
    }
    #hud.hudCompact #log { display:none; }
    #hud.hudCompact #settingsPanel { display:none !important; }
    #hud.hudCompact button, #hud.hudCompact input, #hud.hudCompact select { padding: 6px 8px; }
    #hud.hudCompact #settingsBtn { padding: 6px 8px !important; }
    #hud.hudCompact div[style*="font-weight:800"] { font-size: 13px; }
    #log { margin-top:8px; font-size:12px; color: rgba(230,237,243,0.75); }

    /* Touch controls */
    .stick { position:absolute; bottom:18px; width:140px; height:140px; border-radius:999px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); pointer-events:auto; touch-action:none; }
    #moveStick { left: var(--pad); }
    #lookPad { right: var(--pad); width: calc(var(--btn) * 2.1); height: calc(var(--btn) * 2.1); border-radius: 18px; background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.10); }
    .nub { position:absolute; left:50%; top:50%; width:64px; height:64px; margin-left:-32px; margin-top:-32px; border-radius:999px; background: rgba(124,92,255,0.25); border:1px solid rgba(124,92,255,0.55); }
    /* Use CSS variables so controls scale with screen size */
    :root {
      --pad: 18px;
      --btn: 86px;
      --btn-gap: 12px;
      --bottom: calc(20px + env(safe-area-inset-bottom));
    }
    #btnJump, #btnShoot { position:absolute; bottom: var(--bottom); width: var(--btn); height: var(--btn); border-radius: 999px; pointer-events:auto; touch-action:none; border:1px solid rgba(255,255,255,0.14); display:flex; align-items:center; justify-content:center; }
    #btnShoot { right: calc(var(--pad) + var(--btn) + var(--btn-gap)); background: rgba(255,80,80,0.25); border-color: rgba(255,80,80,0.6); }
    #btnJump { right: calc(var(--pad) + (var(--btn) + var(--btn-gap)) * 2); background: rgba(80,200,255,0.18); border-color: rgba(80,200,255,0.55); }

    #btnSprint, #btnReload, #btnScope { display:flex; align-items:center; justify-content:center; }

    .btnLabel {
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      letter-spacing: 0.6px;
      line-height: 1;
      color: rgba(230,237,243,0.92);
      text-shadow: 0 2px 10px rgba(0,0,0,0.65);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }
    .btnIcon {
      font-size: 26px;
      line-height: 1;
      opacity: 0.95;
    }
    .btnText { display:none; }

    .btnPressed {
      transform: scale(0.94);
      filter: saturate(1.1) brightness(1.2);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.14), 0 8px 20px rgba(0,0,0,0.35);
    }
    #score { position:absolute; top:10px; right:10px; background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:10px 12px; pointer-events:none; font-size:12px; min-width: 140px; }

    /* Extra buttons (sprint/reload) sit above jump/shoot */
    #btnSprint, #btnReload { position:absolute; bottom: calc(var(--bottom) + var(--btn) + 12px); width: var(--btn); height: var(--btn); border-radius: 999px; pointer-events:auto; touch-action:none; border:1px solid rgba(255,255,255,0.14); }
    #btnSprint { right: calc(var(--pad) + (var(--btn) + var(--btn-gap)) * 2); background: rgba(140,140,255,0.16); border-color: rgba(140,140,255,0.55); }
    #btnReload { right: calc(var(--pad) + var(--btn) + var(--btn-gap)); background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.35); }

    /* Responsive tuning */
    @media (max-width: 420px) {
      :root { --pad: 12px; --btn: 72px; --btn-gap: 10px; --bottom: calc(14px + env(safe-area-inset-bottom)); }
    }
    @media (max-width: 360px) {
      :root { --pad: 10px; --btn: 64px; --btn-gap: 8px; --bottom: calc(12px + env(safe-area-inset-bottom)); }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas" style="width:100%; height:100%; touch-action:none;"></canvas>

  <div id="ui">
    <div id="hud">
      <div style="display:flex; align-items:center; gap:10px;">
        <div style="font-weight:800; letter-spacing:0.2px;">Hunter Boyz</div>
        <button id="settingsBtn" style="margin-left:auto; border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08); color:#e6edf3; padding:8px 10px; font-weight:800;">Settings</button>
      </div>

      <div id="settingsPanel" style="margin-top:10px; display:none;">
        <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
          <input id="name" placeholder="Name" maxlength="16" />
          <button id="joinBtn">Join</button>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label style="font-size:12px; opacity:.8;">Look</label>
          <input id="sens" type="range" min="0.6" max="3.0" step="0.1" value="2.2" style="width:140px;" />
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label style="font-size:12px; opacity:.8;">Auto-fire</label>
          <input id="autofire" type="checkbox" />
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label style="font-size:12px; opacity:.8;">Auto-reload</label>
          <input id="autoReload" type="checkbox" checked />
          <span style="font-size:12px; opacity:.6;">(hide Reload button)</span>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label style="font-size:12px; opacity:.8;">Weapon</label>
          <select id="weapon" class="pill" style="cursor:pointer; padding:8px 10px;">
            <option value="rifle">Rifle</option>
            <option value="shotgun">Shotgun</option>
            <option value="sniper">Sniper</option>
          </select>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label style="font-size:12px; opacity:.8;">Aim assist</label>
          <input id="aimAssist" type="checkbox" checked />
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <button id="snapBtn" style="border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08); color:#e6edf3; padding:8px 10px; font-weight:700;">Send snapshot</button>
          <button id="copyLinkBtn" style="border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08); color:#e6edf3; padding:8px 10px; font-weight:700;">Copy link</button>
          <button id="resetLobbyBtn" style="border-radius:10px; border:1px solid rgba(255,255,255,0.18); background: rgba(255,80,80,0.12); color:#ffdede; padding:8px 10px; font-weight:800;">Reset lobby</button>
          <div style="font-size:12px; opacity:.75;">(snapshot saves on server)</div>
        </div>
      </div>

      <div id="log" style="margin-top:10px;">Tip: tap Settings to hide this panel while playing.</div>
    </div>

    <div id="lobby" style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; pointer-events:auto; background: rgba(0,0,0,0.45);">
      <div style="width:min(520px, 92vw); background: rgba(10,14,26,0.92); border:1px solid rgba(255,255,255,0.14); border-radius:16px; padding:14px;">
        <div style="font-weight:900; font-size:18px;">Lobby</div>
        <div id="lobbyPlayers" style="margin-top:10px; font-size:13px; opacity:.9;"></div>
        <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
          <button id="startBtn" style="border-radius:12px; border:1px solid rgba(255,255,255,0.15); background: rgba(124,92,255,0.95); color:white; padding:10px 12px; font-weight:800;">Start</button>
          <div id="waitMsg" style="font-size:12px; opacity:.85;"></div>
        </div>
      </div>
    </div>

    <div id="respawn" style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; pointer-events:none; background: rgba(0,0,0,0.25);">
      <div style="background: rgba(10,14,26,0.85); border:1px solid rgba(255,255,255,0.14); border-radius:16px; padding:14px 16px; font-weight:900;">Respawning…</div>
    </div>

    <div id="score"></div>
    <div id="status" style="position:absolute; left:50%; transform:translateX(-50%); bottom:14px; width:min(520px, 92vw); pointer-events:none;">
      <div style="display:flex; align-items:center; gap:10px;">
        <div style="flex:1; height:10px; border-radius:999px; background: rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.14); overflow:hidden;">
          <div id="hpFill" style="height:100%; width:100%; background: rgba(80,255,140,0.85);"></div>
        </div>
        <div id="hpText" style="font-weight:900; font-size:12px; opacity:.9;">HP 100</div>
        <div id="ammoText" style="font-weight:900; font-size:12px; opacity:.85;">Ammo 12</div>
      </div>
      <div id="hitToast" style="margin-top:10px; text-align:center; font-weight:900; font-size:18px; opacity:0; transition: opacity 120ms ease; color: rgba(255,240,120,0.95); text-shadow: 0 2px 10px rgba(0,0,0,0.6);">HIT!</div>
      <div id="hitDetail" style="margin-top:6px; text-align:center; font-weight:800; font-size:13px; opacity:0; transition: opacity 120ms ease; color: rgba(230,237,243,0.9);">—</div>
    </div>

    <div id="moveStick" class="stick"><div id="moveNub" class="nub"></div></div>
    <div id="lookPad" class="stick"></div>
    <div id="btnJump"><div class="btnLabel"><div class="btnIcon">⇧</div></div></div>
    <div id="btnSprint"><div class="btnLabel"><div class="btnIcon">⚡</div></div></div>
    <div id="btnScope" style="position:absolute; bottom: calc(var(--bottom) + var(--btn) + 12px); right: var(--pad); width: var(--btn); height: var(--btn); border-radius: 999px; pointer-events:auto; touch-action:none; border:1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.18); border-color: rgba(255,255,255,0.35);"><div class="btnLabel"><div class="btnIcon">⌖</div></div></div>
    <div id="btnReload"><div class="btnLabel"><div class="btnIcon">↻</div></div></div>
    <div id="btnShoot"><div class="btnLabel"><div class="btnIcon">◎</div></div></div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    let socket = null;
    let myId = null;
    let world = null;

    // Connection resilience (mobile browsers drop websockets aggressively in background)
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let intentionalClose = false;

    const state = {
      move: { x: 0, z: 0 },
      look: { yaw: 0, pitch: 0 },
      shoot: false,
      jump: false,
      sprint: false,
      scope: false,
      joined: false,
      started: false,
      isHost: false,
      settingsOpen: false,
    };

    const players = new Map(); // id -> mesh
    let fpRig = null;

    function log(msg) {
      document.getElementById('log').textContent = msg;
    }

    function connectAndJoin() {
      const name = (document.getElementById('name').value || 'Hunter').trim();
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';

      // Persistent client id so reconnects replace the old session (prevents "two of myself" bugs).
      let clientId = null;
      try {
        clientId = localStorage.getItem('hunterBoyz.clientId');
        if (!clientId) {
          clientId = (crypto?.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2) + Date.now());
          localStorage.setItem('hunterBoyz.clientId', clientId);
        }
      } catch {
        clientId = String(Math.random()).slice(2) + Date.now();
      }

      const url = `${proto}://${location.host}`;
      intentionalClose = false;

      function scheduleReconnect() {
        if (intentionalClose) return;
        if (reconnectTimer) return;
        reconnectAttempts = Math.min(reconnectAttempts + 1, 8);
        const delay = Math.min(500 * Math.pow(1.6, reconnectAttempts), 6000);
        log(`Reconnecting… (${Math.round(delay)}ms)`);
        reconnectTimer = setTimeout(() => {
          reconnectTimer = null;
          try { openSocket(); } catch {}
        }, delay);
      }

      function openSocket() {
        try { socket?.close(); } catch {}
        socket = new WebSocket(url);

        socket.addEventListener('open', () => {
          reconnectAttempts = 0;
          socket.send(JSON.stringify({ t:'join', name, clientId }));
          log('Connected.');
        });

        socket.addEventListener('message', (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.t === 'welcome') {
            myId = msg.id;
            world = msg.world;
            state.joined = true;
            // Apply immediately so host detection + Start button works even before the next tick.
            if (msg.state) applyState(msg.state);
            trySendStart();
          }
          if (msg.t === 'state') applyState(msg.state);
          if (msg.t === 'shot') renderShot(msg);
          if (msg.t === 'kill') showKill(`${msg.killerName || msg.killer} eliminated ${msg.victimName || msg.victim}`);
          if (msg.t === 'snapSaved') log(`Snapshot saved: ${msg.file}`);
        });

        socket.addEventListener('close', () => {
          state.joined = false;
          try {
            joinBtn.disabled = false;
            nameInput.disabled = false;
          } catch {}
          scheduleReconnect();
        });

        socket.addEventListener('error', () => {
          // Error usually followed by close; still schedule reconnect just in case.
          scheduleReconnect();
        });
      }

      openSocket();

      // Best-effort: when the tab is backgrounded/closed, close the socket so the server
      // removes the player immediately (prevents "ghost host" lingering).
      const closeSock = () => {
        intentionalClose = true;
        try { socket?.close(); } catch {}
      };
      window.addEventListener('pagehide', closeSock, { passive: true });
      window.addEventListener('beforeunload', closeSock, { passive: true });
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          closeSock();
        } else {
          // Coming back from background: reconnect.
          if (!socket || socket.readyState > 1) {
            intentionalClose = false;
            try { openSocket(); } catch {}
          }
        }
      }, { passive: true });
    }

    function applyState(s) {
      lastServerState = s;
      // game flags
      state.started = !!s.game?.started;
      state.isHost = (s.game?.hostId && myId) ? (s.game.hostId === myId) : false;

      // lobby UI
      const lobby = document.getElementById('lobby');
      const lobbyPlayers = document.getElementById('lobbyPlayers');
      const startBtn = document.getElementById('startBtn');
      const waitMsg = document.getElementById('waitMsg');
      if (state.joined && !state.started) {
        lobby.style.display = 'flex';
        // keep settings hidden unless user opens it
        settingsPanel.style.display = state.settingsOpen ? 'block' : 'none';
        lobbyPlayers.innerHTML = s.players.map(p => {
          const tag = p.id === s.game?.hostId ? ' <span style="opacity:.75">(host)</span>' : '';
          const label = `${p.name} #${p.id}`;
          return `<div style="margin:6px 0;"><span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};margin-right:8px;"></span>${label}${tag}</div>`;
        }).join('');
        startBtn.style.display = 'inline-block';
        startBtn.disabled = false;
        startBtn.style.opacity = '1';
        waitMsg.textContent = 'Anyone can tap Start.';
      } else {
        lobby.style.display = 'none';
        // hide settings while playing unless user explicitly opened it
        if (state.started && !state.settingsOpen) settingsPanel.style.display = 'none';
      }

      // respawn UI + HP bar
      const meP = s.players.find(pp => pp.id === myId);
      const respawn = document.getElementById('respawn');
      if (meP) {
        const hp = Math.max(0, Math.min(100, meP.hp));
        document.getElementById('hpText').textContent = `HP ${hp}`;
        const fill = document.getElementById('hpFill');
        fill.style.width = `${hp}%`;
        fill.style.background = hp > 60 ? 'rgba(80,255,140,0.85)' : (hp > 30 ? 'rgba(255,220,100,0.85)' : 'rgba(255,80,80,0.85)');

        const ammo = (typeof meP.ammo === 'number') ? meP.ammo : 0;
        const rel = (meP.reloadInMs || 0);
        document.getElementById('ammoText').textContent = rel > 0 ? `Reloading…` : `Ammo ${ammo}`;

        // Scope UI (sniper)
        const weaponSel = document.getElementById('weapon')?.value;
        const scoped = (weaponSel === 'sniper') && (state.scope === true);
        camera.fov = scoped ? SCOPE_FOV : DEFAULT_FOV;
        scope.isVisible = scoped;
        scopeLines.isVisible = scoped;
        ret.isVisible = !scoped;

        // show spawn protection by tinting HP bar
        const inv = (meP.invulnInMs || 0);
        if (inv > 0) {
          fill.style.filter = 'saturate(0.5) brightness(1.2)';
        } else {
          fill.style.filter = 'none';
        }
      }

      if (meP && meP.hp <= 0) {
        respawn.style.display = 'flex';
        const secs = Math.ceil((meP.respawnInMs || 0) / 1000);
        respawn.firstElementChild.textContent = `Respawning… ${secs}s`;
      } else {
        respawn.style.display = 'none';
      }

      // score
      const scoreDiv = document.getElementById('score');
      scoreDiv.innerHTML = '<div style="font-weight:800; margin-bottom:6px;">Score</div>' +
        s.players.sort((a,b)=>b.score-a.score).map(p => {
          const me = p.id === myId ? ' (you)' : '';
          return `<div><span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};margin-right:8px;"></span>${p.name}${me}: ${p.score} <span style="opacity:.7">HP ${p.hp}</span></div>`;
        }).join('');

      const liveIds = new Set(s.players.map(p => p.id));
      for (const [id, mesh] of players.entries()) {
        if (!liveIds.has(id)) {
          try {
            const tag = mesh?.metadata?.nameTag;
            if (tag) {
              try { advancedTexture.removeControl(tag); } catch {}
              try { tag.dispose(); } catch {}
            }
          } catch {}
          mesh.dispose();
          players.delete(id);
        }
      }

      for (const p of s.players) {
        let mesh = players.get(p.id);
        if (!mesh) {
          // Player model (simple low-poly humanoid)
          const root = new BABYLON.TransformNode(`p_${p.id}_root`, scene);

          const mat = new BABYLON.StandardMaterial(`m_${p.id}`, scene);
          mat.diffuseColor = BABYLON.Color3.FromHexString(rgbToHex(cssToRgb(p.color)));
          mat.emissiveColor = mat.diffuseColor.scale(0.15);
          mat.specularColor = new BABYLON.Color3(0,0,0);

          const body = BABYLON.MeshBuilder.CreateCapsule(`p_${p.id}_body`, { radius: 0.35, height: 1.2, subdivisions: 6 }, scene);
          body.parent = root;
          body.position.y = 0.65;
          body.material = mat;

          const head = BABYLON.MeshBuilder.CreateSphere(`p_${p.id}_head`, { diameter: 0.55, segments: 8 }, scene);
          head.parent = root;
          head.position.y = 1.55;
          head.material = mat;

          const armMat = new BABYLON.StandardMaterial(`ma_${p.id}`, scene);
          armMat.diffuseColor = mat.diffuseColor.scale(0.95);
          armMat.emissiveColor = mat.emissiveColor.scale(0.7);
          armMat.specularColor = new BABYLON.Color3(0,0,0);

          const lArm = BABYLON.MeshBuilder.CreateBox(`p_${p.id}_larm`, { width: 0.18, height: 0.5, depth: 0.18 }, scene);
          lArm.parent = root;
          lArm.position.set(-0.42, 1.05, 0.0);
          lArm.rotation.z = 0.15;
          lArm.material = armMat;

          const rArm = BABYLON.MeshBuilder.CreateBox(`p_${p.id}_rarm`, { width: 0.18, height: 0.5, depth: 0.18 }, scene);
          rArm.parent = root;
          rArm.position.set(0.42, 1.05, 0.0);
          rArm.rotation.z = -0.15;
          rArm.material = armMat;

          // A tiny gun block on right arm so others see a weapon
          const gunMat = new BABYLON.StandardMaterial(`mg_${p.id}`, scene);
          gunMat.diffuseColor = new BABYLON.Color3(0.08, 0.09, 0.11);
          gunMat.emissiveColor = new BABYLON.Color3(0.01, 0.01, 0.01);
          gunMat.specularColor = new BABYLON.Color3(0,0,0);

          const gun = BABYLON.MeshBuilder.CreateBox(`p_${p.id}_gun`, { width: 0.12, height: 0.10, depth: 0.30 }, scene);
          gun.parent = root;
          gun.position.set(0.32, 1.05, 0.38);
          gun.material = gunMat;

          // Name tag (so you know who's shooting)
          let nameTag = null;
          try {
            const tag = new BABYLON.GUI.Rectangle(`tag_${p.id}`);
            tag.background = 'rgba(0,0,0,0.45)';
            tag.thickness = 1;
            tag.color = 'rgba(255,255,255,0.22)';
            tag.cornerRadius = 6;
            tag.height = '24px';
            tag.width = '140px';
            tag.linkWithMesh(root);
            tag.linkOffsetY = -95;
            tag.isPointerBlocker = false;

            const text = new BABYLON.GUI.TextBlock();
            text.text = p.name;
            text.color = 'rgba(230,237,243,0.95)';
            text.fontSize = 12;
            text.fontWeight = '800';
            tag.addControl(text);

            advancedTexture.addControl(tag);
            nameTag = tag;
          } catch {}

          root.metadata = { target: new BABYLON.Vector3(p.x, (p.y || 1.8) - 0.8, p.z), targetYaw: p.yaw, nameTag };
          players.set(p.id, root);
          mesh = root;
        }

        // Hide your own body in first-person (otherwise you see yourself when turning)
        if (p.id === myId) {
          mesh.isVisible = false;
          // Hide your own nametag too.
          try { if (mesh?.metadata?.nameTag) mesh.metadata.nameTag.isVisible = false; } catch {}
          ensureFirstPersonRig();
        } else {
          mesh.isVisible = true;
          try { if (mesh?.metadata?.nameTag) mesh.metadata.nameTag.isVisible = true; } catch {}
        }

        // Smooth other players (reduce jitter)
        if (mesh.metadata) {
          mesh.metadata.target.x = p.x;
          mesh.metadata.target.y = (p.y || 1.8) - 0.8;
          mesh.metadata.target.z = p.z;
          mesh.metadata.targetYaw = p.yaw;
        }

        if (p.id !== myId) {
          // actual lerp happens in render loop
        } else {
          mesh.position.x = p.x;
          mesh.position.y = (p.y || 1.8) - 0.8;
          mesh.position.z = p.z;
          mesh.rotation.y = p.yaw;
        }

        if (p.id === myId) {
          camera.position.x = p.x;
          camera.position.y = (p.y || 1.8);
          camera.position.z = p.z;
          camera.rotation.y = p.yaw;
          camera.rotation.x = p.pitch;
        }
      }
    }

    // Helpers to parse hsl() to rgb
    function cssToRgb(css) {
      // expects hsl(h s% l%)
      const m = css.match(/hsl\(([-\d.]+)\s+([\d.]+)%\s+([\d.]+)%\)/);
      if (!m) return {r:200,g:200,b:200};
      const h = (+m[1]) / 360;
      const s = (+m[2]) / 100;
      const l = (+m[3]) / 100;
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      let r,g,b;
      if (s === 0) {
        r=g=b=l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
    }
    function rgbToHex({r,g,b}) {
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }

    // Scene
    const scene = new BABYLON.Scene(engine);
    const DEFAULT_FOV = 0.9;
    const SCOPE_FOV = 0.35;
    // More colorful vibe
    scene.clearColor = new BABYLON.Color4(0.72, 0.86, 0.98, 1);

    const light = new BABYLON.HemisphericLight('h', new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.95;

    const dir = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.4, -1, 0.2), scene);
    dir.intensity = 0.55;

    // Subtle sky gradient (big inverted sphere)
    const sky = BABYLON.MeshBuilder.CreateSphere('sky', { diameter: 500, segments: 12 }, scene);
    sky.infiniteDistance = true;
    sky.isPickable = false;
    sky.scaling.x = -1;
    const skyMat = new BABYLON.StandardMaterial('skyMat', scene);
    skyMat.backFaceCulling = false;
    skyMat.disableLighting = true;
    skyMat.diffuseColor = new BABYLON.Color3(0,0,0);
    // Fake gradient by using emissive color + vertex colors-like effect via fresnel
    // Light-blue sky vibe
    skyMat.emissiveColor = new BABYLON.Color3(0.55, 0.75, 0.95);
    skyMat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
    skyMat.emissiveFresnelParameters.bias = 0.15;
    skyMat.emissiveFresnelParameters.power = 1.6;
    skyMat.emissiveFresnelParameters.leftColor = new BABYLON.Color3(0.82, 0.92, 1.00);
    skyMat.emissiveFresnelParameters.rightColor = new BABYLON.Color3(0.35, 0.70, 0.98);
    sky.material = skyMat;

    const camera = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 2, -5), scene);
    camera.fov = DEFAULT_FOV;
    camera.minZ = 0.05;

    // Ground + some blocks
    const ground = BABYLON.MeshBuilder.CreateGround('g', { width: 60, height: 60 }, scene);
    // Floor: make it feel like a real floor (grass-ish)
    const gmat = new BABYLON.StandardMaterial('gm', scene);
    gmat.diffuseColor = new BABYLON.Color3(0.22, 0.50, 0.28);
    gmat.emissiveColor = new BABYLON.Color3(0.03, 0.06, 0.03);
    gmat.specularColor = new BABYLON.Color3(0,0,0);
    ground.material = gmat;

    function ensureFirstPersonRig() {
      if (fpRig) return fpRig;
      const root = new BABYLON.TransformNode('fpRoot', scene);
      root.parent = camera;

      // Hands (very simple blocks)
      const handMat = new BABYLON.StandardMaterial('handMat', scene);
      handMat.diffuseColor = new BABYLON.Color3(0.85, 0.72, 0.62);
      handMat.specularColor = new BABYLON.Color3(0,0,0);

      // First-person rig (more hand/gun-like using capsules + better proportions)
      const skinMat = new BABYLON.StandardMaterial('skinMat', scene);
      skinMat.diffuseColor = new BABYLON.Color3(0.90, 0.76, 0.66);
      skinMat.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

      function capsule(name, radius, height) {
        return BABYLON.MeshBuilder.CreateCapsule(name, { radius, height, subdivisions: 6 }, scene);
      }

      function makeHand(name, side /* -1 left, +1 right */, parent) {
        const handRoot = new BABYLON.TransformNode(name, scene);
        handRoot.parent = parent;

        // Palm
        const palm = BABYLON.MeshBuilder.CreateBox(name + '_palm', { width: 0.09, height: 0.03, depth: 0.12 }, scene);
        palm.material = skinMat;
        palm.parent = handRoot;
        palm.position.set(0, 0, 0);

        // Fingers (4 capsules) curled around grip
        const fingerOffsets = [-0.030, -0.010, 0.010, 0.030];
        const fingers = [];
        for (let i = 0; i < 4; i++) {
          const f = capsule(`${name}_f${i}`, 0.012, 0.08);
          f.material = skinMat;
          f.parent = handRoot;
          f.position.set(fingerOffsets[i], -0.018, 0.055);
          f.rotation.x = 1.15; // curl
          fingers.push(f);
        }

        // Thumb
        const thumb = capsule(name + '_thumb', 0.012, 0.07);
        thumb.material = skinMat;
        thumb.parent = handRoot;
        thumb.position.set(0.05 * side, -0.005, 0.010);
        thumb.rotation.z = -0.9 * side;
        thumb.rotation.x = 0.6;

        return { handRoot, palm, fingers, thumb };
      }

      // Left forearm + hand
      const lFore = capsule('lFore', 0.055, 0.30);
      lFore.material = skinMat;
      lFore.parent = root;
      lFore.position.set(-0.20, -0.24, 0.60);
      lFore.rotation.x = 0.35;
      lFore.rotation.z = 0.18;

      const leftHand = makeHand('leftHand', -1, root);
      leftHand.handRoot.position.set(-0.20, -0.34, 0.76);
      leftHand.handRoot.rotation.x = 0.15;
      leftHand.handRoot.rotation.z = 0.10;

      // Right forearm + hand
      const rFore = capsule('rFore', 0.055, 0.30);
      rFore.material = skinMat;
      rFore.parent = root;
      rFore.position.set(0.22, -0.24, 0.60);
      rFore.rotation.x = 0.40;
      rFore.rotation.z = -0.15;

      const rightHand = makeHand('rightHand', +1, root);
      rightHand.handRoot.position.set(0.22, -0.35, 0.78);
      rightHand.handRoot.rotation.x = 0.12;
      rightHand.handRoot.rotation.z = -0.08;

      // Jiachen: hide hands/forearms; keep only the gun visible in first-person.
      try {
        lFore.isVisible = false;
        rFore.isVisible = false;
        leftHand.handRoot.setEnabled(false);
        rightHand.handRoot.setEnabled(false);
      } catch {}

      // Gun: use Kenney GLB model if available; fall back to simple primitives.
      const gunRoot = new BABYLON.TransformNode('gunRoot', scene);
      gunRoot.parent = root;
      gunRoot.position.set(0.08, -0.30, 0.80);

      let receiver = null, barrel = null, stock = null, grip = null;

      (async () => {
        try {
          const result = await BABYLON.SceneLoader.ImportMeshAsync(
            null,
            '/',
            'assets/kenney/blaster-kit/Models/GLB format/blaster-a.glb',
            scene
          );
          const imported = new BABYLON.TransformNode('kenneyGun', scene);
          for (const m of result.meshes) {
            if (m === scene.meshes[0]) continue;
            // Some meshes may be empty nodes; attach everything.
            if (m.parent === null) m.parent = imported;
          }
          imported.parent = gunRoot;
          imported.scaling.setAll(0.6);
          imported.rotation.x = 0;
          imported.rotation.y = Math.PI;
          imported.position.set(0.02, -0.02, 0.02);
        } catch (e) {
          // fallback primitives
          const gunMat = new BABYLON.StandardMaterial('gunMat', scene);
          gunMat.diffuseColor = new BABYLON.Color3(0.10, 0.11, 0.13);
          gunMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.025);
          gunMat.specularColor = new BABYLON.Color3(0.02,0.02,0.02);

          receiver = BABYLON.MeshBuilder.CreateBox('gunReceiver', { width:0.10, height:0.09, depth:0.22 }, scene);
          receiver.material = gunMat;
          receiver.parent = gunRoot;
          receiver.position.set(0.02, 0.00, 0.02);

          barrel = BABYLON.MeshBuilder.CreateCylinder('gunBarrel', { diameter:0.045, height:0.42, tessellation: 10 }, scene);
          barrel.material = gunMat;
          barrel.parent = gunRoot;
          barrel.rotation.x = Math.PI / 2;
          barrel.position.set(0.02, 0.00, 0.30);

          stock = BABYLON.MeshBuilder.CreateBox('gunStock', { width:0.09, height:0.08, depth:0.14 }, scene);
          stock.material = gunMat;
          stock.parent = gunRoot;
          stock.position.set(0.02, -0.01, -0.14);

          grip = BABYLON.MeshBuilder.CreateBox('gunGrip', { width:0.05, height:0.10, depth:0.06 }, scene);
          grip.material = gunMat;
          grip.parent = gunRoot;
          grip.position.set(0.05, -0.08, 0.02);
          grip.rotation.x = 0.25;
        }
      })();

      // Slight tilt so it feels more like aiming forward
      root.rotation.x = 0.01;
      root.rotation.y = 0.0;

      // Muzzle flash (hidden most of the time)
      const flashMat = new BABYLON.StandardMaterial('flashMat', scene);
      flashMat.emissiveColor = new BABYLON.Color3(1.0, 0.85, 0.25);
      flashMat.diffuseColor = new BABYLON.Color3(0,0,0);
      flashMat.alpha = 0.95;

      const muzzleFlash = BABYLON.MeshBuilder.CreatePlane('muzzleFlash', { size:0.10 }, scene);
      muzzleFlash.material = flashMat;
      muzzleFlash.parent = gunRoot;
      muzzleFlash.position.set(0.02, 0.00, 0.56);
      muzzleFlash.rotation.y = Math.PI; // face camera
      muzzleFlash.isVisible = false;

      fpRig = { root, lFore, leftHand, rFore, rightHand, gunRoot, muzzleFlash };
      return fpRig;
    }

    const blockMat = new BABYLON.StandardMaterial('bm', scene);
    // Walls/obstacles: concrete wall vibe
    blockMat.diffuseColor = new BABYLON.Color3(0.62, 0.64, 0.68);
    blockMat.emissiveColor = new BABYLON.Color3(0.04, 0.04, 0.04);

    function addBlock(x,y,z,w=2,h=2,d=2) {
      const b = BABYLON.MeshBuilder.CreateBox('b', { width:w, height:h, depth:d }, scene);
      b.position.set(x, y + h/2, z);
      b.material = blockMat;
      return b;
    }
    addBlock(0,0,0, 3,3,3);
    addBlock(-8,0,6, 4,2,6);
    addBlock(10,0,-6, 6,3,3);

    // Aim reticle
    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('ui2');
    const ret = new BABYLON.GUI.Ellipse();
    ret.width = '10px';
    ret.height = '10px';
    ret.thickness = 2;
    ret.color = 'rgba(255,255,255,0.65)';
    ret.background = 'transparent';
    advancedTexture.addControl(ret);

    // Scope overlay (sniper)
    const scope = new BABYLON.GUI.Ellipse();
    scope.width = '82%';
    scope.height = '82%';
    scope.thickness = 4;
    scope.color = 'rgba(0,0,0,0.65)';
    scope.background = 'transparent';
    scope.isVisible = false;
    advancedTexture.addControl(scope);

    const scopeLines = new BABYLON.GUI.TextBlock();
    scopeLines.text = '+';
    scopeLines.color = 'rgba(255,255,255,0.65)';
    scopeLines.fontSize = 44;
    scopeLines.isVisible = false;
    advancedTexture.addControl(scopeLines);

    function flashReticle(kind) {
      const orig = ret.color;
      if (kind === 'hit') ret.color = 'rgba(255,80,80,0.95)';
      else ret.color = 'rgba(255,240,120,0.95)';
      setTimeout(() => { ret.color = orig; }, 80);
    }

    // Sound FX (procedural WebAudio; no external files)
    const SFX = (() => {
      let ctx = null;
      let unlockPromise = null;

      function ensure() {
        if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        return ctx;
      }

      function unlockIfNeeded() {
        const c = ensure();
        if (c.state !== 'suspended') return Promise.resolve();
        if (!unlockPromise) {
          unlockPromise = c.resume().catch(()=>{}).finally(() => { unlockPromise = null; });
        }
        return unlockPromise;
      }

      function play(fn) {
        const c = ensure();
        if (c.state === 'suspended') {
          // iOS will sometimes suspend audio again; resume, then play.
          unlockIfNeeded().then(() => { try { fn(c); } catch {} });
          return;
        }
        try { fn(c); } catch {}
      }

      // Proactively unlock audio on the first real gesture.
      // (Otherwise iOS will drop some early/occasional SFX.)
      window.addEventListener('pointerdown', () => { unlockIfNeeded(); }, { passive: true });
      window.addEventListener('touchstart', () => { unlockIfNeeded(); }, { passive: true });

      function noiseBuffer(c, seconds = 0.15) {
        const len = Math.floor(c.sampleRate * seconds);
        const buf = c.createBuffer(1, len, c.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1);
        return buf;
      }

      function gunshot(weapon = 'rifle') {
        play((c) => {
          const t0 = c.currentTime + 0.001;

          const w = String(weapon || 'rifle');
          const cfg = (w === 'shotgun')
            ? {
                noise: 0.18,
                bpFreq: 900,
                bpQ: 0.7,
                lpFreq: 2600,
                gainPeak: 0.38,
                gainMid: 0.06,
                gainMidAt: 0.09,
                gainEndAt: 0.22,
                thumpType: 'sine',
                thumpStart: 120,
                thumpEnd: 70,
                thumpPeak: 0.16,
                thumpEndAt: 0.16,
              }
            : (w === 'sniper')
            ? {
                noise: 0.14,
                bpFreq: 1600,
                bpQ: 1.1,
                lpFreq: 5200,
                gainPeak: 0.30,
                gainMid: 0.03,
                gainMidAt: 0.05,
                gainEndAt: 0.18,
                thumpType: 'triangle',
                thumpStart: 220,
                thumpEnd: 110,
                thumpPeak: 0.12,
                thumpEndAt: 0.13,
                // small "tail" click to feel snappier
                clickHz: 3200,
                clickMs: 18,
                clickGain: 0.015,
              }
            : {
                // rifle default
                noise: 0.11,
                bpFreq: 1300,
                bpQ: 0.9,
                lpFreq: 3800,
                gainPeak: 0.24,
                gainMid: 0.02,
                gainMidAt: 0.06,
                gainEndAt: 0.14,
                thumpType: 'triangle',
                thumpStart: 170,
                thumpEnd: 95,
                thumpPeak: 0.10,
                thumpEndAt: 0.11,
              };

          // Noise burst
          const src = c.createBufferSource();
          src.buffer = noiseBuffer(c, cfg.noise);

          // Shape it: bandpass + slight distortion + fast decay
          const bp = c.createBiquadFilter();
          bp.type = 'bandpass';
          bp.frequency.setValueAtTime(cfg.bpFreq, t0);
          bp.Q.setValueAtTime(cfg.bpQ, t0);

          const lp = c.createBiquadFilter();
          lp.type = 'lowpass';
          lp.frequency.setValueAtTime(cfg.lpFreq, t0);

          const shaper = c.createWaveShaper();
          const curve = new Float32Array(256);
          for (let i = 0; i < curve.length; i++) {
            const x = (i / (curve.length - 1)) * 2 - 1;
            curve[i] = Math.tanh(2.0 * x);
          }
          shaper.curve = curve;

          const g = c.createGain();
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.exponentialRampToValueAtTime(cfg.gainPeak, t0 + 0.003);
          g.gain.exponentialRampToValueAtTime(cfg.gainMid, t0 + cfg.gainMidAt);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + cfg.gainEndAt);

          // Low "thump"
          const o = c.createOscillator();
          o.type = cfg.thumpType;
          o.frequency.setValueAtTime(cfg.thumpStart, t0);
          o.frequency.exponentialRampToValueAtTime(cfg.thumpEnd, t0 + 0.09);
          const og = c.createGain();
          og.gain.setValueAtTime(0.0001, t0);
          og.gain.exponentialRampToValueAtTime(cfg.thumpPeak, t0 + 0.004);
          og.gain.exponentialRampToValueAtTime(0.0001, t0 + cfg.thumpEndAt);

          const mix = c.createGain();
          mix.gain.value = 0.78;

          src.connect(bp).connect(shaper).connect(lp).connect(g).connect(mix);
          o.connect(og).connect(mix);

          // Optional click (sniper)
          let clickOsc = null;
          if (cfg.clickHz) {
            clickOsc = c.createOscillator();
            clickOsc.type = 'square';
            clickOsc.frequency.value = cfg.clickHz;
            const cg = c.createGain();
            cg.gain.value = cfg.clickGain || 0.01;
            clickOsc.connect(cg).connect(mix);
            clickOsc.start(t0);
            clickOsc.stop(t0 + (cfg.clickMs || 12) / 1000);
          }

          mix.connect(c.destination);

          src.start(t0);
          src.stop(t0 + cfg.gainEndAt);
          o.start(t0);
          o.stop(t0 + cfg.thumpEndAt);
        });
      }

      function tick(freq, durMs, gainVal) {
        play((c) => {
          const o = c.createOscillator();
          const g = c.createGain();
          o.type = 'square';
          o.frequency.value = freq;
          g.gain.value = gainVal;
          o.connect(g).connect(c.destination);
          o.start();
          setTimeout(() => { try { o.stop(); } catch {} }, durMs);
        });
      }

      return {
        shoot: (weapon) => gunshot(weapon),
        hit: () => tick(760, 60, 0.02),
        kill: () => tick(320, 120, 0.02),
      };
    })();

    function showKill(text) {
      // reuse hit toast area for now
      const d = document.getElementById('hitDetail');
      d.textContent = text;
      d.style.opacity = '1';
      clearTimeout(showKill._t);
      showKill._t = setTimeout(() => { d.style.opacity = '0'; }, 1200);
      SFX.kill();
    }

    function showHitToast(detail) {
      const el = document.getElementById('hitToast');
      const d = document.getElementById('hitDetail');
      el.style.opacity = '1';
      d.textContent = detail || '';
      d.style.opacity = detail ? '1' : '0';
      clearTimeout(showHitToast._t);
      showHitToast._t = setTimeout(() => { el.style.opacity = '0'; d.style.opacity = '0'; }, 260);
    }

    function renderShot(s) {
      const color = s.hit ? new BABYLON.Color3(1.0, 0.35, 0.35) : new BABYLON.Color3(1.0, 0.9, 0.45);
      const sy = (s.sy || 1.8) - 0.2;

      const segments = [];
      if (Array.isArray(s.traces) && s.traces.length) {
        for (const tr of s.traces) {
          segments.push([new BABYLON.Vector3(s.sx, sy, s.sz), new BABYLON.Vector3(tr.ex, sy, tr.ez)]);
        }
      } else {
        segments.push([new BABYLON.Vector3(s.sx, sy, s.sz), new BABYLON.Vector3(s.ex, sy, s.ez)]);
      }

      for (const pts of segments) {
        const lines = BABYLON.MeshBuilder.CreateLines('shot', { points: pts }, scene);
        lines.color = color;
        lines.alpha = 0.9;
        setTimeout(() => lines.dispose(), 260);
      }

      if (s.from === myId) {
        flashReticle(s.hit ? 'hit' : 'shoot');
        if (fpRig?.muzzleFlash) {
          fpRig.muzzleFlash.isVisible = true;
          // tiny recoil
          if (fpRig?.gunRoot) fpRig.gunRoot.position.z -= 0.03;
          setTimeout(() => {
            if (fpRig?.muzzleFlash) fpRig.muzzleFlash.isVisible = false;
            if (fpRig?.gunRoot) fpRig.gunRoot.position.z += 0.03;
          }, 70);
        }
        SFX.shoot(s.weapon || 'rifle');
        if (s.hit) {
          const target = s.hit;
          const hp = (typeof s.hitHp === 'number') ? s.hitHp : null;
          const detail = hp === null ? `Hit ${target}` : `Hit ${target} (HP ${hp})`;
          showHitToast(detail);
          SFX.hit();
        }
      }

      if (s.hit && s.hit === myId && s.from !== myId) {
        flashReticle('hit');
      }

      if (s.hit && players.has(s.hit)) {
        const m = players.get(s.hit);
        const mat = m?.material;
        if (mat && mat.emissiveColor) {
          const prev = mat.emissiveColor.clone();
          mat.emissiveColor = new BABYLON.Color3(0.8, 0.1, 0.1);
          setTimeout(() => { try { mat.emissiveColor = prev; } catch {} }, 120);
        }
      }
    }

    // Touch controls
    function makeStick(el, nubEl, onMove) {
      let active = false;

      const rect = () => el.getBoundingClientRect();
      const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

      const setNub = (dx, dy) => {
        if (!nubEl) return;
        const max = 44;
        nubEl.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
      };

      const prevent = (e) => {
        e.preventDefault();
        e.stopPropagation();
      };

      el.addEventListener('contextmenu', (e) => prevent(e));

      el.addEventListener('pointerdown', (e) => {
        prevent(e);
        active = true;
        el.setPointerCapture(e.pointerId);
        setNub(0,0);
        onMove(0,0,true);
      }, { passive: false });

      el.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        const r = rect();
        const dx = e.clientX - (r.left + r.width/2);
        const dy = e.clientY - (r.top + r.height/2);
        const max = 55;
        const nx = clamp(dx / max, -1, 1);
        const ny = clamp(dy / max, -1, 1);
        setNub(dx,dy);
        onMove(nx, ny, false);
      }, { passive: false });

      const end = (e) => {
        if (!active) return;
        prevent(e);
        active = false;
        setNub(0,0);
        onMove(0,0,true);
      };
      el.addEventListener('pointerup', end, { passive: false });
      el.addEventListener('pointercancel', end, { passive: false });
      el.addEventListener('pointerleave', end, { passive: false });
    }

    makeStick(
      document.getElementById('moveStick'),
      document.getElementById('moveNub'),
      (nx, ny) => {
        // stick up = forward; add small deadzone so it's easier to control
        const dz = 0.14;
        const mag = Math.hypot(nx, ny);
        if (mag < dz) { state.move.x = 0; state.move.z = 0; return; }
        const scale = (mag - dz) / (1 - dz);
        const ux = nx / mag;
        const uy = ny / mag;
        state.move.x = ux * scale;
        state.move.z = -uy * scale;
      }
    );

    // look pad: drag deltas
    // Look controls:
    // - Primary: right look pad
    // - Fallback: drag anywhere on the right half of the screen
    (() => {
      const pad = document.getElementById('lookPad');
      let active = false;
      let last = null;
      let sens = parseFloat(document.getElementById('sens').value || '2.2');
      document.getElementById('sens').addEventListener('input', (e) => {
        sens = parseFloat(e.target.value || '2.2');
      });

      const prevent = (e) => {
        if (!e) return;
        e.preventDefault();
        e.stopPropagation();
      };

      function applyDelta(dx, dy) {
        state.look.yaw += dx * 0.004 * sens;
        state.look.pitch += dy * 0.003 * sens;
        // Limit looking up/down so you don't get lost on mobile.
        // (radians) ~ -35° down to +20° up
        const MIN_PITCH = -0.6;
        const MAX_PITCH = 0.35;
        state.look.pitch = Math.max(MIN_PITCH, Math.min(MAX_PITCH, state.look.pitch));
      }

      function startAt(x, y) {
        active = true;
        last = { x, y };
      }

      function moveTo(x, y) {
        if (!active || !last) return;
        const dx = x - last.x;
        const dy = y - last.y;
        last = { x, y };
        applyDelta(dx, dy);
      }

      function end() {
        active = false;
        last = null;
      }

      // Disable long-press menu
      pad.addEventListener('contextmenu', (e) => prevent(e));
      canvas.addEventListener('contextmenu', (e) => prevent(e));

      // Pointer events on pad
      pad.addEventListener('pointerdown', (e) => {
        prevent(e);
        pad.setPointerCapture(e.pointerId);
        startAt(e.clientX, e.clientY);
      }, { passive: false });

      pad.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        moveTo(e.clientX, e.clientY);
      }, { passive: false });

      pad.addEventListener('pointerup', (e) => { prevent(e); end(); }, { passive: false });
      pad.addEventListener('pointercancel', (e) => { prevent(e); end(); }, { passive: false });
      pad.addEventListener('pointerleave', (e) => { prevent(e); end(); }, { passive: false });

      // Fallback: drag on canvas right half (ONLY while game is started)
      canvas.addEventListener('pointerdown', (e) => {
        if (!state.joined || !state.started || state.settingsOpen) return;
        if (e.clientX < window.innerWidth * 0.5) return;
        prevent(e);
        canvas.setPointerCapture(e.pointerId);
        startAt(e.clientX, e.clientY);
      }, { passive: false });

      canvas.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        moveTo(e.clientX, e.clientY);
      }, { passive: false });

      canvas.addEventListener('pointerup', (e) => { if (active) prevent(e); end(); }, { passive: false });
      canvas.addEventListener('pointercancel', (e) => { if (active) prevent(e); end(); }, { passive: false });

      // iOS Safari sometimes prefers touch events; add a lightweight touch fallback.
      canvas.addEventListener('touchstart', (e) => {
        if (!state.joined || !state.started || state.settingsOpen) return;
        const t = e.touches && e.touches[0];
        if (!t) return;
        if (t.clientX < window.innerWidth * 0.5) return;
        prevent(e);
        startAt(t.clientX, t.clientY);
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        if (!active) return;
        const t = e.touches && e.touches[0];
        if (!t) return;
        prevent(e);
        moveTo(t.clientX, t.clientY);
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => { if (active) prevent(e); end(); }, { passive: false });
      canvas.addEventListener('touchcancel', (e) => { if (active) prevent(e); end(); }, { passive: false });
    })();

    // Buttons
    function holdButton(el, on) {
      const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
      const press = (v) => {
        try { el.classList.toggle('btnPressed', !!v); } catch {}
        on(!!v);
      };
      el.addEventListener('contextmenu', (e) => prevent(e));
      el.addEventListener('pointerdown', (e)=>{ prevent(e); el.setPointerCapture(e.pointerId); press(true); }, { passive:false });
      el.addEventListener('pointerup', (e)=>{ prevent(e); press(false); }, { passive:false });
      el.addEventListener('pointercancel', (e)=>{ prevent(e); press(false); }, { passive:false });
      el.addEventListener('pointerleave', (e)=>{ prevent(e); press(false); }, { passive:false });
    }
    // Shoot: hold-to-fire by default; optional tap-to-toggle (autofire)
    const autoFireEl = document.getElementById('autofire');
    const shootEl = document.getElementById('btnShoot');
    let shootToggled = false;
    holdButton(shootEl, (v)=> {
      if (autoFireEl.checked) {
        // Tap-to-toggle when autofire is enabled.
        if (v) { shootToggled = !shootToggled; state.shoot = shootToggled; }
      } else {
        // Hold-to-fire when autofire is disabled.
        state.shoot = v;
        if (!v) shootToggled = false;
      }
    });

    // If user turns OFF autofire while shooting is toggled ON, stop immediately.
    autoFireEl.addEventListener('change', () => {
      if (!autoFireEl.checked) {
        shootToggled = false;
        state.shoot = false;
      }
    });
    holdButton(document.getElementById('btnJump'), (v)=> state.jump = v);
    holdButton(document.getElementById('btnSprint'), (v)=> state.sprint = v);

    // Reload: tap
    (() => {
      const el = document.getElementById('btnReload');
      const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
      const fire = (e) => {
        prevent(e);
        try { el.classList.add('btnPressed'); setTimeout(() => el.classList.remove('btnPressed'), 90); } catch {}
        if (!socket || socket.readyState !== 1) return;
        socket.send(JSON.stringify({ t:'reload' }));
      };
      el.addEventListener('click', fire);
      el.addEventListener('pointerdown', fire, { passive:false });
      el.addEventListener('touchend', fire, { passive:false });
    })();

    // Scope: toggle (only affects sniper)
    (() => {
      const el = document.getElementById('btnScope');
      const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
      const fire = (e) => {
        prevent(e);
        try { el.classList.add('btnPressed'); setTimeout(() => el.classList.remove('btnPressed'), 90); } catch {}
        state.scope = !state.scope;
      };
      el.addEventListener('click', fire);
      el.addEventListener('pointerdown', fire, { passive:false });
      el.addEventListener('touchend', fire, { passive:false });
    })();

    // Join
    const joinBtn = document.getElementById('joinBtn');
    const nameInput = document.getElementById('name');
    const autoReloadEl = document.getElementById('autoReload');
    const reloadBtn = document.getElementById('btnReload');

    // Persist username + settings locally so re-joining is fast.
    const NAME_KEY = 'hunterBoyz.name';
    const AUTO_RELOAD_KEY = 'hunterBoyz.autoReload';
    try {
      const saved = localStorage.getItem(NAME_KEY);
      if (saved && !nameInput.value) nameInput.value = saved;

      const savedAR = localStorage.getItem(AUTO_RELOAD_KEY);
      if (savedAR !== null && autoReloadEl) autoReloadEl.checked = (savedAR === '1');
    } catch {}

    function syncReloadButtonVisibility() {
      const on = !!autoReloadEl?.checked;
      try { if (reloadBtn) reloadBtn.style.display = on ? 'none' : 'flex'; } catch {}
    }
    syncReloadButtonVisibility();
    autoReloadEl?.addEventListener('change', () => {
      try { localStorage.setItem(AUTO_RELOAD_KEY, autoReloadEl.checked ? '1' : '0'); } catch {}
      syncReloadButtonVisibility();
    });
    const startBtn = document.getElementById('startBtn');
    const snapBtn = document.getElementById('snapBtn');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const resetLobbyBtn = document.getElementById('resetLobbyBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');

    function doJoin(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      if (state.joined) return;

      // Save name + settings before joining.
      try {
        const v = (nameInput.value || '').trim();
        if (v) localStorage.setItem(NAME_KEY, v);
        if (autoReloadEl) localStorage.setItem(AUTO_RELOAD_KEY, autoReloadEl.checked ? '1' : '0');
      } catch {}

      connectAndJoin();
      joinBtn.disabled = true;
      nameInput.disabled = true;
      // Hide settings while playing; you can reopen via Settings.
      state.settingsOpen = false;
      settingsPanel.style.display = 'none';
      try { syncHudCompact(); } catch {}
    }

    let pendingStart = false;
    function trySendStart() {
      if (!pendingStart) return;
      if (!socket || socket.readyState !== 1) return;
      if (!state.joined) return;
      pendingStart = false;
      try { socket.send(JSON.stringify({ t:'start' })); } catch {}
    }

    function doStart(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      pendingStart = true;
      trySendStart();
    }

    function doSnap(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      if (!socket || socket.readyState !== 1) return;
      // capture canvas as jpg to keep size small
      let dataUrl = null;
      try { dataUrl = canvas.toDataURL('image/jpeg', 0.7); }
      catch { try { dataUrl = canvas.toDataURL('image/png'); } catch {} }
      if (!dataUrl) return;
      socket.send(JSON.stringify({ t:'snap', dataUrl }));
      log('Snapshot sent (saving on server)…');
    }

    async function doCopyLink(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      const link = location.href;
      try {
        await navigator.clipboard.writeText(link);
        log('Link copied. Paste into the other phone.');
      } catch {
        log('Copy failed. Link: ' + link);
      }
    }

    // iOS Safari can be flaky with click depending on viewport/overlays; wire multiple events.
    joinBtn.addEventListener('click', doJoin);
    joinBtn.addEventListener('pointerdown', doJoin, { passive: false });
    joinBtn.addEventListener('touchend', doJoin, { passive: false });

    startBtn.addEventListener('click', doStart);
    startBtn.addEventListener('pointerdown', doStart, { passive: false });
    startBtn.addEventListener('touchend', doStart, { passive: false });

    snapBtn.addEventListener('click', doSnap);
    snapBtn.addEventListener('pointerdown', doSnap, { passive: false });
    snapBtn.addEventListener('touchend', doSnap, { passive: false });

    copyLinkBtn.addEventListener('click', doCopyLink);
    copyLinkBtn.addEventListener('pointerdown', doCopyLink, { passive: false });
    copyLinkBtn.addEventListener('touchend', doCopyLink, { passive: false });

    function doResetLobby(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      if (!socket || socket.readyState !== 1) return;
      socket.send(JSON.stringify({ t:'resetLobby' }));
      log('Lobby reset (kicking ghosts)…');
    }
    resetLobbyBtn.addEventListener('click', doResetLobby);
    resetLobbyBtn.addEventListener('pointerdown', doResetLobby, { passive: false });
    resetLobbyBtn.addEventListener('touchend', doResetLobby, { passive: false });

    const hudEl = document.getElementById('hud');
    function syncHudCompact() {
      // Compact whenever settings are closed.
      try { hudEl.classList.toggle('hudCompact', !state.settingsOpen); } catch {}
    }
    syncHudCompact();

    let lastSettingsToggleAt = 0;
    function toggleSettings(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      const now = Date.now();
      // Prevent double-toggle from iOS firing multiple events (touchend + click)
      if (now - lastSettingsToggleAt < 350) return;
      lastSettingsToggleAt = now;
      state.settingsOpen = !state.settingsOpen;
      settingsPanel.style.display = state.settingsOpen ? 'block' : 'none';
      syncHudCompact();
    }
    settingsBtn.addEventListener('click', toggleSettings);
    settingsBtn.addEventListener('pointerdown', toggleSettings, { passive:false });
    settingsBtn.addEventListener('touchend', toggleSettings, { passive:false });

    // Keep last server state for aim assist
    let lastServerState = null;

    // Network tick
    let seq = 0;
    let lastSend = performance.now();
    engine.runRenderLoop(() => {
      // Smooth remote players
      for (const [id, mesh] of players.entries()) {
        if (id === myId) continue;
        if (!mesh.metadata?.target) continue;
        const lerp = 0.22;
        mesh.position.x += (mesh.metadata.target.x - mesh.position.x) * lerp;
        mesh.position.y += (mesh.metadata.target.y - mesh.position.y) * lerp;
        mesh.position.z += (mesh.metadata.target.z - mesh.position.z) * lerp;
        // shortest-angle yaw lerp (avoid spinning the long way around)
        let dy = (mesh.metadata.targetYaw - mesh.rotation.y);
        while (dy > Math.PI) dy -= Math.PI * 2;
        while (dy < -Math.PI) dy += Math.PI * 2;
        mesh.rotation.y += dy * 0.25;
      }

      scene.render();

      if (socket && socket.readyState === 1 && state.joined) {
        // disable gameplay input until started
        if (!state.started) return;

        const t = performance.now();
        const dt = Math.min(0.2, (t - lastSend) / 1000);
        if (t - lastSend > 50) {
          lastSend = t;
          // Aim assist: nudge yaw slightly toward closest enemy within a small cone.
          const aimAssistOn = document.getElementById('aimAssist')?.checked;
          if (aimAssistOn && state.shoot && lastServerState && myId) {
            const me = lastServerState.players.find(p => p.id === myId);
            if (me) {
              let best = null;
              for (const p of lastServerState.players) {
                if (p.id === myId) continue;
                if (p.hp <= 0) continue;
                const dx = p.x - me.x;
                const dz = p.z - me.z;
                const dist = Math.hypot(dx, dz);
                if (dist < 0.1 || dist > 18) continue;
                const targetYaw = Math.atan2(dx, dz);
                let dy = targetYaw - state.look.yaw;
                while (dy > Math.PI) dy -= Math.PI*2;
                while (dy < -Math.PI) dy += Math.PI*2;
                const cone = 0.25;
                if (Math.abs(dy) > cone) continue;
                const score = Math.abs(dy) + dist * 0.02;
                if (!best || score < best.score) best = { dy, score };
              }
              if (best) state.look.yaw += best.dy * 0.18; // small nudge
            }
          }

          const wSel = document.getElementById('weapon')?.value;
          const weapon = (wSel === 'shotgun' || wSel === 'sniper') ? wSel : 'rifle';

          const autoReload = !!document.getElementById('autoReload')?.checked;

          socket.send(JSON.stringify({
            t:'input',
            seq: seq++,
            dt,
            move: state.move,
            look: state.look,
            shoot: !!state.shoot,
            jump: !!state.jump,
            sprint: !!state.sprint,
            weapon,
            autoReload,
          }));
        }
      }
    });

    // Reduce iOS Safari back-swipe accidental navigation.
    // Not a perfect guarantee (browser-level gesture), but helps a lot during gameplay.
    (() => {
      let tracking = false;
      let startX = 0;
      let startY = 0;
      const EDGE = 18; // px

      const onStart = (e) => {
        const t = e.touches && e.touches[0];
        if (!t) return;
        tracking = (t.clientX <= EDGE);
        startX = t.clientX;
        startY = t.clientY;
      };

      const onMove = (e) => {
        if (!tracking) return;
        const t = e.touches && e.touches[0];
        if (!t) return;
        const dx = t.clientX - startX;
        const dy = Math.abs(t.clientY - startY);
        // If it's a mostly-horizontal swipe from the left edge, block it.
        if (dx > 8 && dy < 35) {
          e.preventDefault();
          e.stopPropagation();
        }
      };

      const end = () => { tracking = false; };

      document.addEventListener('touchstart', onStart, { passive: true });
      document.addEventListener('touchmove', onMove, { passive: false });
      document.addEventListener('touchend', end, { passive: true });
      document.addEventListener('touchcancel', end, { passive: true });
    })();

    // iOS: best-effort suppression of double-tap-to-zoom during gameplay.
    // This cannot override Accessibility Zoom, but it prevents the common browser smart-zoom.
    (() => {
      let lastTouchEnd = 0;
      const handler = (e) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
          e.preventDefault();
        }
        lastTouchEnd = now;
      };
      document.addEventListener('touchend', handler, { passive: false });
      // Also block pinch-zoom gestures where supported.
      document.addEventListener('gesturestart', (e) => { e.preventDefault(); }, { passive: false });
      document.addEventListener('gesturechange', (e) => { e.preventDefault(); }, { passive: false });
      document.addEventListener('gestureend', (e) => { e.preventDefault(); }, { passive: false });
    })();

    window.addEventListener('resize', () => engine.resize());
  </script>
</body>
</html>
