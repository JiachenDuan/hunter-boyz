<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Hunter Boyz</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#05070f; color:#e6edf3; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; }
    /* iOS long-press / selection prevention */
    body, #ui, canvas, button, input, select, textarea {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    #ui { position: fixed; inset: 0; pointer-events:none; }
    #hud { position:absolute; top:10px; left:10px; background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:10px 12px; pointer-events:auto; }
    #hud input { border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color:#e6edf3; padding:8px 10px; width: 160px; }
    #hud button { margin-left:6px; border-radius:10px; border:1px solid rgba(255,255,255,0.15); background: rgba(124,92,255,0.9); color:white; padding:8px 10px; }
    #log { margin-top:8px; font-size:12px; color: rgba(230,237,243,0.75); }

    /* Touch controls */
    .stick { position:absolute; bottom:18px; width:140px; height:140px; border-radius:999px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); pointer-events:auto; touch-action:none; }
    #moveStick { left:18px; }
    #lookPad { right:18px; width: 180px; height: 180px; border-radius: 18px; background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.10); }
    .nub { position:absolute; left:50%; top:50%; width:64px; height:64px; margin-left:-32px; margin-top:-32px; border-radius:999px; background: rgba(124,92,255,0.25); border:1px solid rgba(124,92,255,0.55); }
    #btnJump, #btnShoot { position:absolute; bottom: 26px; right: 220px; width: 86px; height: 86px; border-radius: 999px; pointer-events:auto; touch-action:none; border:1px solid rgba(255,255,255,0.14); }
    #btnShoot { right: 122px; background: rgba(255,80,80,0.25); border-color: rgba(255,80,80,0.6); }
    #btnJump { right: 318px; background: rgba(80,200,255,0.18); border-color: rgba(80,200,255,0.55); }
    #score { position:absolute; top:10px; right:10px; background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:10px 12px; pointer-events:none; font-size:12px; min-width: 140px; }

    @media (max-width: 420px) {
      #btnJump { right: 240px; }
      #btnShoot { right: 140px; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas" style="width:100%; height:100%; touch-action:none;"></canvas>

  <div id="ui">
    <div id="hud">
      <div style="font-weight:800; letter-spacing:0.2px;">Hunter Boyz</div>
      <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
        <input id="name" placeholder="Name" maxlength="16" />
        <button id="joinBtn">Join</button>
      </div>
      <div id="log">Tip: same Wiâ€‘Fi, open this page on each iPhone.</div>
    </div>

    <div id="score"></div>

    <div id="moveStick" class="stick"><div id="moveNub" class="nub"></div></div>
    <div id="lookPad" class="stick"></div>
    <div id="btnJump"></div>
    <div id="btnShoot"></div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    let socket = null;
    let myId = null;
    let world = null;

    const state = {
      move: { x: 0, z: 0 },
      look: { yaw: 0, pitch: 0 },
      shoot: false,
      joined: false,
    };

    const players = new Map(); // id -> mesh
    let fpRig = null;

    function log(msg) {
      document.getElementById('log').textContent = msg;
    }

    function connectAndJoin() {
      const name = (document.getElementById('name').value || 'Hunter').trim();
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      socket = new WebSocket(`${proto}://${location.host}`);

      socket.addEventListener('open', () => {
        socket.send(JSON.stringify({ t:'join', name }));
        log('Joined. Use left stick to move, right pad to look, red to shoot.');
      });

      socket.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.t === 'welcome') {
          myId = msg.id;
          world = msg.world;
          state.joined = true;
        }
        if (msg.t === 'state') {
          applyState(msg.state);
        }
        if (msg.t === 'shot') {
          renderShot(msg);
        }
      });

      socket.addEventListener('close', () => {
        log('Disconnected. Refresh to rejoin.');
        state.joined = false;
      });
    }

    function applyState(s) {
      // score
      const scoreDiv = document.getElementById('score');
      scoreDiv.innerHTML = '<div style="font-weight:800; margin-bottom:6px;">Score</div>' +
        s.players.sort((a,b)=>b.score-a.score).map(p => {
          const me = p.id === myId ? ' (you)' : '';
          return `<div><span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};margin-right:8px;"></span>${p.name}${me}: ${p.score} <span style="opacity:.7">HP ${p.hp}</span></div>`;
        }).join('');

      const liveIds = new Set(s.players.map(p => p.id));
      for (const [id, mesh] of players.entries()) {
        if (!liveIds.has(id)) {
          mesh.dispose();
          players.delete(id);
        }
      }

      for (const p of s.players) {
        let mesh = players.get(p.id);
        if (!mesh) {
          mesh = BABYLON.MeshBuilder.CreateBox(`p_${p.id}`, { size: 1.2 }, scene);
          mesh.position.y = 1.0;
          const mat = new BABYLON.StandardMaterial(`m_${p.id}`, scene);
          mat.diffuseColor = BABYLON.Color3.FromHexString(rgbToHex(cssToRgb(p.color)));
          mat.emissiveColor = mat.diffuseColor.scale(0.25);
          mesh.material = mat;
          players.set(p.id, mesh);
        }

        // Hide your own body in first-person (otherwise you see yourself when turning)
        if (p.id === myId) {
          mesh.isVisible = false;
          ensureFirstPersonRig();
        } else {
          mesh.isVisible = true;
        }

        mesh.position.x = p.x;
        mesh.position.z = p.z;
        mesh.rotation.y = p.yaw;

        if (p.id === myId) {
          camera.position.x = p.x;
          camera.position.z = p.z;
          camera.rotation.y = p.yaw;
          camera.rotation.x = p.pitch;
        }
      }
    }

    // Helpers to parse hsl() to rgb
    function cssToRgb(css) {
      // expects hsl(h s% l%)
      const m = css.match(/hsl\(([-\d.]+)\s+([\d.]+)%\s+([\d.]+)%\)/);
      if (!m) return {r:200,g:200,b:200};
      const h = (+m[1]) / 360;
      const s = (+m[2]) / 100;
      const l = (+m[3]) / 100;
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      let r,g,b;
      if (s === 0) {
        r=g=b=l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
    }
    function rgbToHex({r,g,b}) {
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }

    // Scene
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.03,0.04,0.08,1);

    const light = new BABYLON.HemisphericLight('h', new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.9;

    const camera = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 2, -5), scene);
    camera.fov = 0.9;
    camera.minZ = 0.05;

    // Ground + some blocks
    const ground = BABYLON.MeshBuilder.CreateGround('g', { width: 60, height: 60 }, scene);
    const gmat = new BABYLON.StandardMaterial('gm', scene);
    gmat.diffuseColor = new BABYLON.Color3(0.12,0.18,0.32);
    gmat.specularColor = new BABYLON.Color3(0,0,0);
    ground.material = gmat;

    function ensureFirstPersonRig() {
      if (fpRig) return fpRig;
      const root = new BABYLON.TransformNode('fpRoot', scene);
      root.parent = camera;

      // Hands (very simple blocks)
      const handMat = new BABYLON.StandardMaterial('handMat', scene);
      handMat.diffuseColor = new BABYLON.Color3(0.85, 0.72, 0.62);
      handMat.specularColor = new BABYLON.Color3(0,0,0);

      const leftHand = BABYLON.MeshBuilder.CreateBox('leftHand', { width:0.18, height:0.18, depth:0.32 }, scene);
      leftHand.material = handMat;
      leftHand.parent = root;
      leftHand.position.set(-0.18, -0.18, 0.55);

      const rightHand = BABYLON.MeshBuilder.CreateBox('rightHand', { width:0.18, height:0.18, depth:0.32 }, scene);
      rightHand.material = handMat;
      rightHand.parent = root;
      rightHand.position.set(0.22, -0.20, 0.55);

      // Gun
      const gunMat = new BABYLON.StandardMaterial('gunMat', scene);
      gunMat.diffuseColor = new BABYLON.Color3(0.10, 0.12, 0.16);
      gunMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.03);
      gunMat.specularColor = new BABYLON.Color3(0,0,0);

      const gunBody = BABYLON.MeshBuilder.CreateBox('gunBody', { width:0.22, height:0.14, depth:0.55 }, scene);
      gunBody.material = gunMat;
      gunBody.parent = root;
      gunBody.position.set(0.12, -0.22, 0.62);

      const gunBarrel = BABYLON.MeshBuilder.CreateBox('gunBarrel', { width:0.10, height:0.10, depth:0.30 }, scene);
      gunBarrel.material = gunMat;
      gunBarrel.parent = root;
      gunBarrel.position.set(0.12, -0.20, 0.92);

      // Muzzle flash (hidden most of the time)
      const flashMat = new BABYLON.StandardMaterial('flashMat', scene);
      flashMat.emissiveColor = new BABYLON.Color3(1.0, 0.85, 0.25);
      flashMat.diffuseColor = new BABYLON.Color3(0,0,0);
      flashMat.alpha = 0.95;

      const muzzleFlash = BABYLON.MeshBuilder.CreatePlane('muzzleFlash', { size:0.22 }, scene);
      muzzleFlash.material = flashMat;
      muzzleFlash.parent = root;
      muzzleFlash.position.set(0.12, -0.20, 1.10);
      muzzleFlash.isVisible = false;

      fpRig = { root, leftHand, rightHand, gunBody, gunBarrel, muzzleFlash };
      return fpRig;
    }

    const blockMat = new BABYLON.StandardMaterial('bm', scene);
    blockMat.diffuseColor = new BABYLON.Color3(0.25,0.30,0.55);
    blockMat.emissiveColor = blockMat.diffuseColor.scale(0.08);

    function addBlock(x,y,z,w=2,h=2,d=2) {
      const b = BABYLON.MeshBuilder.CreateBox('b', { width:w, height:h, depth:d }, scene);
      b.position.set(x, y + h/2, z);
      b.material = blockMat;
      return b;
    }
    addBlock(0,0,0, 3,3,3);
    addBlock(-8,0,6, 4,2,6);
    addBlock(10,0,-6, 6,3,3);

    // Aim reticle
    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('ui2');
    const ret = new BABYLON.GUI.Ellipse();
    ret.width = '10px';
    ret.height = '10px';
    ret.thickness = 2;
    ret.color = 'rgba(255,255,255,0.65)';
    ret.background = 'transparent';
    advancedTexture.addControl(ret);

    function flashReticle(kind) {
      const orig = ret.color;
      if (kind === 'hit') ret.color = 'rgba(255,80,80,0.95)';
      else ret.color = 'rgba(255,240,120,0.95)';
      setTimeout(() => { ret.color = orig; }, 80);
    }

    function renderShot(s) {
      // Tracer line (very short-lived)
      const color = s.hit ? new BABYLON.Color3(1.0, 0.35, 0.35) : new BABYLON.Color3(1.0, 0.9, 0.45);
      const pts = [
        new BABYLON.Vector3(s.sx, (s.sy || 1.8) - 0.2, s.sz),
        new BABYLON.Vector3(s.ex, (s.ey || 1.8) - 0.2, s.ez),
      ];
      const lines = BABYLON.MeshBuilder.CreateLines('shot', { points: pts }, scene);
      lines.color = color;
      lines.alpha = 0.9;
      setTimeout(() => lines.dispose(), 70);

      if (s.from === myId) {
        flashReticle(s.hit ? 'hit' : 'shoot');
        // simple muzzle flash in first-person
        if (fpRig?.muzzleFlash) {
          fpRig.muzzleFlash.isVisible = true;
          setTimeout(() => { if (fpRig?.muzzleFlash) fpRig.muzzleFlash.isVisible = false; }, 60);
        }
      }
    }

    // Touch controls
    function makeStick(el, nubEl, onMove) {
      let active = false;

      const rect = () => el.getBoundingClientRect();
      const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

      const setNub = (dx, dy) => {
        if (!nubEl) return;
        const max = 44;
        nubEl.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
      };

      const prevent = (e) => {
        e.preventDefault();
        e.stopPropagation();
      };

      el.addEventListener('contextmenu', (e) => prevent(e));

      el.addEventListener('pointerdown', (e) => {
        prevent(e);
        active = true;
        el.setPointerCapture(e.pointerId);
        setNub(0,0);
        onMove(0,0,true);
      }, { passive: false });

      el.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        const r = rect();
        const dx = e.clientX - (r.left + r.width/2);
        const dy = e.clientY - (r.top + r.height/2);
        const max = 55;
        const nx = clamp(dx / max, -1, 1);
        const ny = clamp(dy / max, -1, 1);
        setNub(dx,dy);
        onMove(nx, ny, false);
      }, { passive: false });

      const end = (e) => {
        if (!active) return;
        prevent(e);
        active = false;
        setNub(0,0);
        onMove(0,0,true);
      };
      el.addEventListener('pointerup', end, { passive: false });
      el.addEventListener('pointercancel', end, { passive: false });
      el.addEventListener('pointerleave', end, { passive: false });
    }

    makeStick(
      document.getElementById('moveStick'),
      document.getElementById('moveNub'),
      (nx, ny) => {
        // stick up = forward
        state.move.x = nx;
        state.move.z = -ny;
      }
    );

    // look pad: drag deltas
    // Look controls:
    // - Primary: right look pad
    // - Fallback: drag anywhere on the right half of the screen
    (() => {
      const pad = document.getElementById('lookPad');
      let active = false;
      let last = null;
      const sens = 2.2;

      const prevent = (e) => {
        if (!e) return;
        e.preventDefault();
        e.stopPropagation();
      };

      function applyDelta(dx, dy) {
        state.look.yaw += dx * 0.004 * sens;
        state.look.pitch += dy * 0.003 * sens;
        state.look.pitch = Math.max(-1.2, Math.min(1.2, state.look.pitch));
      }

      function startAt(x, y) {
        active = true;
        last = { x, y };
      }

      function moveTo(x, y) {
        if (!active || !last) return;
        const dx = x - last.x;
        const dy = y - last.y;
        last = { x, y };
        applyDelta(dx, dy);
      }

      function end() {
        active = false;
        last = null;
      }

      // Disable long-press menu
      pad.addEventListener('contextmenu', (e) => prevent(e));
      canvas.addEventListener('contextmenu', (e) => prevent(e));

      // Pointer events on pad
      pad.addEventListener('pointerdown', (e) => {
        prevent(e);
        pad.setPointerCapture(e.pointerId);
        startAt(e.clientX, e.clientY);
      }, { passive: false });

      pad.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        moveTo(e.clientX, e.clientY);
      }, { passive: false });

      pad.addEventListener('pointerup', (e) => { prevent(e); end(); }, { passive: false });
      pad.addEventListener('pointercancel', (e) => { prevent(e); end(); }, { passive: false });
      pad.addEventListener('pointerleave', (e) => { prevent(e); end(); }, { passive: false });

      // Fallback: drag on canvas right half
      canvas.addEventListener('pointerdown', (e) => {
        if (!state.joined) return;
        if (e.clientX < window.innerWidth * 0.5) return;
        prevent(e);
        canvas.setPointerCapture(e.pointerId);
        startAt(e.clientX, e.clientY);
      }, { passive: false });

      canvas.addEventListener('pointermove', (e) => {
        if (!active) return;
        prevent(e);
        moveTo(e.clientX, e.clientY);
      }, { passive: false });

      canvas.addEventListener('pointerup', (e) => { if (active) prevent(e); end(); }, { passive: false });
      canvas.addEventListener('pointercancel', (e) => { if (active) prevent(e); end(); }, { passive: false });

      // iOS Safari sometimes prefers touch events; add a lightweight touch fallback.
      canvas.addEventListener('touchstart', (e) => {
        if (!state.joined) return;
        const t = e.touches && e.touches[0];
        if (!t) return;
        if (t.clientX < window.innerWidth * 0.5) return;
        prevent(e);
        startAt(t.clientX, t.clientY);
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        if (!active) return;
        const t = e.touches && e.touches[0];
        if (!t) return;
        prevent(e);
        moveTo(t.clientX, t.clientY);
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => { if (active) prevent(e); end(); }, { passive: false });
      canvas.addEventListener('touchcancel', (e) => { if (active) prevent(e); end(); }, { passive: false });
    })();

    // Buttons
    function holdButton(el, on) {
      const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
      el.addEventListener('contextmenu', (e) => prevent(e));
      el.addEventListener('pointerdown', (e)=>{ prevent(e); el.setPointerCapture(e.pointerId); on(true); }, { passive:false });
      el.addEventListener('pointerup', (e)=>{ prevent(e); on(false); }, { passive:false });
      el.addEventListener('pointercancel', (e)=>{ prevent(e); on(false); }, { passive:false });
      el.addEventListener('pointerleave', (e)=>{ prevent(e); on(false); }, { passive:false });
    }
    holdButton(document.getElementById('btnShoot'), (v)=> state.shoot = v);
    holdButton(document.getElementById('btnJump'), (v)=>{/* jump later */});

    // Join
    const joinBtn = document.getElementById('joinBtn');
    const nameInput = document.getElementById('name');
    function doJoin(e) {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      if (state.joined) return;
      connectAndJoin();
      joinBtn.disabled = true;
      nameInput.disabled = true;
    }
    // iOS Safari can be flaky with click depending on viewport/overlays; wire multiple events.
    joinBtn.addEventListener('click', doJoin);
    joinBtn.addEventListener('pointerdown', doJoin, { passive: false });
    joinBtn.addEventListener('touchend', doJoin, { passive: false });

    // Network tick
    let seq = 0;
    let lastSend = performance.now();
    engine.runRenderLoop(() => {
      scene.render();
      if (socket && socket.readyState === 1 && state.joined) {
        const t = performance.now();
        const dt = Math.min(0.2, (t - lastSend) / 1000);
        if (t - lastSend > 50) {
          lastSend = t;
          socket.send(JSON.stringify({
            t:'input',
            seq: seq++,
            dt,
            move: state.move,
            look: state.look,
            shoot: !!state.shoot,
          }));
        }
      }
    });

    window.addEventListener('resize', () => engine.resize());
  </script>
</body>
</html>
